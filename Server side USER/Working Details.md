# Workflows
This section will explain the idea and working pf the code by dividing the code into several workflows (i.e. a set of related code which has a particular set of related actions as its purpose).
There are various separate workflows in this backend, as listed below:

1. [Authorization](#authorization-workflow)
2. [Vendor functions](#vendor-functions-workflow)
3. [User Location](#user-location-workflow) 
4. [Place Display](#place-display-workflow)
5. [User Cart](#user-cart-workflow)
6. [Onesignal Notifications](#OneSignal-notification-workflow)
7. [Ordering](#ordering-workflow)


## Authorization workflow

This workflow is responsible for authentication and fixing role of accounts. Current roles are USER(for customer) and VENDOR(for vendor).Requests are received by AuthController, business logic is present in AuthServiceImpl and repositories accessed are CustomerRepository and VendorRepository. Payload class UserAuth is used for communication.

Authorization makes use of cookies to know if user is logged in. Login credentials are username and password. Password is hashed using SHA256 algorithm before being stored in the database. Login or account creation causes creation of a random long value. This value serves as session ID and needs to be sent as a cookie for every endpoint access with "/secure" in its path. This cookie is set to last for 1 hour at client side.

Password sent for new account creation has no constraints placed on it so validation checks such as length or no special characters must be applied before request is sent to endpoint.

All requests to endpoint must have Role cookie having value as USER or VENDOR. Only USER requests can access endpoints under "/secure1" and only VENDOR requests can access endpoints under "/secure2" path.

## Vendor functions workflow

This workflow is responsible for handling actions by vendor account. Requests are received by VendorController, business logic in VendorServiceImpl and repositories affected are VendorRepository and ItemRepository.

Actions possible by the vendor are setting coordinates of its place and getting/setting of its menu items and their attributes.

Items are created as separate entities because there might be additional properties to be added later on such as description, picture, etc.

## User Location workflow

This workflow is responsible for CRUD of location coordinates for each user. Requests are received by LocationController, business logic is in LocationServiceImpl and repository accessed is UserRepository.
Locations are stored in the form of geographical coordinates associated with a string description. No limit has been set on the number of locations per customer and no restrictions have been placed on the choice of coordinates.

## Place Display workflow

This workflow is responsible for retrieval of places and place details. Requests are received by PlaceListController, business logic is in PlaceListServiceImpl and repositories accessed are VendorRepository and ItemRepository.

A list of places is retrieved which are present within a 10km by 10km square centered at geographical coordinates in the request. The measurements here are the geographical distance.

The place details retrieved is the menu(item list) set by a particular place.

## User Cart workflow

This workflow is responsible for CRUD of menu items in cart. Cart is unique and private to every user. Requests are received by CartController, business logic is in CartServiceImpl and repositories accessed are ItemRepository and CustomerRepository.

No limit has been set on the number of items in cart. Orders to multiple vendors can be made simultaneously and each such sub-order (called order segment) has a separate preparation status. An order is a collection of such order segments.

Note: price attached to cart items are fetched from ItemRepository each time at cart change and not based on cart data from client-side(even though price is available at client-side and using it will reduce processing) to prevent tampering in cost generation.

## Onesignal Notification workflow

This workflow is responsible for saving OneSignal id generated by client(customer or vendor) on notification subscription. Requests are received by NotificationController, business logic in in NotifServiceImpl and repositories accessed are CustomerRepository and VendorRepository. NotifServiceImpl also contains the function of sending notifications to a list of OneSignal ids.

<a id="Flaw1">Flaw:</a> Each user must be restricted to one device for notification. This is implemented by not linking OneSignal id with client name in OneSignal. This means that every time a user allows subscription on new device, he gets a new OneSignal id which replaces the previous OneSignal id in our database. However, this does not delete previous OneSignal id (called player id in OneSignal records) resulting in creation of orphans in OneSignal records for every new device-browser combination that user allows subscription from.

<a id="Flaw2">Flaw:</a> The frontend also does not prevent notifications if another user is currently using the device. Say User A allowed subscription on device-browser DBR. Then, he executed some action which causes notification updates at a later point in time. Then, User A logs out. Next, User B logs in. Now, any notifications intended for user A and user B will be shown to anyone accessing this device, which is undesirable. Also, OneSignal id is not linked with client id. Therefore OneSignal understands that notification permission has already been provided for this device-browser combination and fails to differentiate change in users. One solution for both these issues is to disable notifications for user A on this device-browser (DBR) when user A logs out.

## Ordering workflow

This workflow is responsible for order generation from user cart, retrieval of details for viewing by both vendor and customer, handling status update by vendor and sending notifications to both vendor and customer at necessary stages. Requests are received by OrderController, business logic is in OrderServiceImpl and repositories accessed are VendorRepository, CustomerRepository, OrderRepository and ItemRepository. OrderServiceImpl also uses business logic present in CartServiceImpl and NotifServiceImpl.

Order creation creates an order out of all items in the cart and clears the cart. Once an order is made it cannot be changed by customer. Similarly, any status updates made by vendor are also irreversible. On order creation, a vendor can accept or reject an order. On acceptance, the next stage is order prepration. Next, vendor can signal when an order has been sent for delivery and finally when the order has been delivered.

# Flaws

1. Barebones UI and functional UX.
2. <a href="#Flaw1">Creation of orphans in OneSignal records.</a>
3. <a href="#Flaw2">OneSignal notifications do not differentiate between multiple users on same device.</a>

# Possible Expansions

1. A separate portal for delivery drivers with a suitable hand-off method between vendor and delivery driver such as via OTP or QR code. This portal may also include delivery statistics for every person and location tracking of order delivery for vendor and customer viewing.

2. Analytics for every vendor with details such as dish ordering frequency, addition to cart frequency, customerbase area, etc. 

3. Review and rating system for customers.

4. Addition of pictures and descriptions for restaurant and individual dishes.

5. A panel for admin use.